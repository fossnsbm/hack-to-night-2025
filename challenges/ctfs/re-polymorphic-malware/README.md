# Polymorphic Malware

## Challenge Description
A binary that modifies its own code at runtime, generating polymorphic variants of its functions. The challenge is to understand the underlying algorithm that remains constant despite the changing code, and to discover how to extract the hidden flag.

## Challenge Setup

1. Compile the challenge binary:
   ```
   make
   ```

2. If needed, use additional hardening techniques:
   ```
   strip polymorphic
   ```

3. For an extra challenge, consider adding:
   - Anti-debugging checks
   - Code integrity verification
   - Additional entropy sources for polymorphism

## Challenge Solution

To solve this challenge, participants need to:

1. Understand the concept of polymorphic code
2. Identify the core function patterns that don't change
3. Reverse engineer how the code modifies itself
4. Extract and decrypt the flag

### Detailed Solution Steps

1. Static analysis first:
   - Identify the encrypted flag data in the binary
   - Note the XOR key (0x42)
   - Understand the template functions before they're modified

2. Dynamic analysis:
   - Use a debugger to track memory allocation and execution
   - Set breakpoints after the polymorphic code generation
   - Inspect the executable memory region created by mmap
   - Analyze how the original functions are transformed

3. Extract the flag:
   - Option 1: Let the program decrypt the flag and extract it from memory
   - Option 2: Manually decrypt the flag using the XOR key:
     ```
     flag_data = [0x83, 0x9e, 0x93, 0x86, ...]
     key = 0x42
     plain_text = ''.join(chr(b ^ key) for b in flag_data)
     ```

4. The decrypted flag is: `flag{s3lf_m0d1fy1ng_c0d3_1s_h4rd_t0_4n4lyz3}`

### Alternative Solution Method

Instead of reverse engineering the entire polymorphic engine, participants can use dynamic analysis to observe the decrypted flag in memory:

1. Run the program in a debugger
2. Set a breakpoint at the `strcmp()` function call
3. Examine the function arguments to see the plain text flag
4. Alternatively, dump memory after the decryption function is called

### Patch Method

A simple patch solution:
1. Locate the section where the program checks the password
2. Modify the conditional jump to always take the success path
3. Run the patched binary to get the flag directly

## Challenge Analysis

### Difficulty Elements
- Self-modifying code (hard to analyze statically)
- Runtime code generation and execution
- Low-level x86 instruction manipulation
- Memory mapping and execution protections

### Learning Objectives
- Understanding polymorphic code techniques
- Memory protection mechanisms
- Runtime code modification
- Binary instrumentation

### Estimated Solve Time
- 3-5 hours for experienced reverse engineers
- 6-10 hours for intermediate participants 