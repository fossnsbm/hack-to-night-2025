#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/mman.h>

// Flag data - encrypted
unsigned char encrypted_flag[] = {
    0x83, 0x9e, 0x93, 0x86, 0xc1, 0x8f, 0x9a, 0x93, 0x96, 0xdf, 0x92, 0xda, 0x9b, 0xda, 0x96, 0x8e, 
    0xda, 0x8b, 0xdc, 0x9b, 0x9a, 0xdf, 0x93, 0x8f, 0xdf, 0x94, 0x9c, 0x8d, 0x9b, 0xdf, 0x8b, 0xdc, 
    0xdf, 0x9c, 0x8a, 0x9c, 0x93, 0x8e, 0x90, 0x9a, 0xc2
};

// XOR key
unsigned char key = 0x42;

// Flag length
#define FLAG_LENGTH (sizeof(encrypted_flag))

// Function type definitions for our polymorphic code
typedef void (*DecryptFunc)(unsigned char*, size_t, unsigned char);
typedef int (*CheckFunc)(const char*, size_t);

// The polymorphic code will be generated at runtime
// We need space for it
#define POLY_CODE_SIZE 4096
unsigned char polymorphic_code[POLY_CODE_SIZE];

// Original (template) decrypt function that will be modified at runtime
void decrypt_flag_template(unsigned char* data, size_t length, unsigned char key) {
    for (size_t i = 0; i < length; i++) {
        data[i] ^= key;
    }
}

// Original (template) check function that will be modified at runtime
int check_flag_template(const char* input, size_t length) {
    // This function will be polymorphically modified at runtime
    // The base check just ensures the input starts with "flag{"
    if (length < 5) return 0;
    if (input[0] != 'f') return 0;
    if (input[1] != 'l') return 0;
    if (input[2] != 'a') return 0;
    if (input[3] != 'g') return 0;
    if (input[4] != '{') return 0;
    return 1;
}

// Get size of a function by assuming it ends at the next function
size_t get_func_size(const void* func, const void* next_func) {
    return (size_t)((const unsigned char*)next_func - (const unsigned char*)func);
}

// Function to generate random junk instructions
// These won't affect functionality but will change the binary signature
void add_junk_code(unsigned char* code, size_t* offset) {
    int junk_type = rand() % 5;
    
    switch (junk_type) {
        case 0: // NOP sequence
            {
                int count = rand() % 5 + 1;
                for (int i = 0; i < count; i++) {
                    code[(*offset)++] = 0x90; // NOP
                }
            }
            break;
            
        case 1: // Push/Pop registers (no effect)
            {
                int reg = rand() % 8;
                code[(*offset)++] = 0x50 + reg; // PUSH reg
                code[(*offset)++] = 0x58 + reg; // POP reg
            }
            break;
            
        case 2: // MOV reg, reg (self-move, no effect)
            {
                int reg = rand() % 8;
                code[(*offset)++] = 0x89;
                code[(*offset)++] = 0xC0 + (reg << 3) + reg; // MOV reg, reg
            }
            break;
            
        case 3: // Dead conditional jump (never taken)
            {
                code[(*offset)++] = 0x31; // XOR eax, eax
                code[(*offset)++] = 0xC0;
                code[(*offset)++] = 0x3C; // CMP al, 1
                code[(*offset)++] = 0x01;
                code[(*offset)++] = 0x74; // JE +2
                code[(*offset)++] = 0x02;
                code[(*offset)++] = 0xEB; // JMP +0
                code[(*offset)++] = 0x00;
            }
            break;
            
        case 4: // INC and DEC in sequence (no effect)
            {
                int reg = rand() % 8;
                code[(*offset)++] = 0x40 + reg; // INC reg
                code[(*offset)++] = 0x48 + reg; // DEC reg
            }
            break;
    }
}

// Function to create polymorphic versions of our functions
void generate_polymorphic_code() {
    size_t decrypt_size = get_func_size(decrypt_flag_template, check_flag_template);
    size_t check_size = get_func_size(check_flag_template, generate_polymorphic_code);
    
    // Get current position in our polymorphic code buffer
    size_t offset = 0;
    
    // Copy and modify the decrypt function
    memcpy(polymorphic_code + offset, decrypt_flag_template, decrypt_size);
    
    // Insert junk code within the decrypt function at random positions
    size_t decrypt_end = offset + decrypt_size;
    
    // We need to carefully place junk code to not break functionality
    // For this simplified example, we'll just add some at the beginning
    add_junk_code(polymorphic_code, &offset);
    
    // Skip ahead to where we would start the check function
    offset = decrypt_end;
    
    // Copy and modify the check function
    memcpy(polymorphic_code + offset, check_flag_template, check_size);
    
    // Add junk code within the check function
    size_t check_end = offset + check_size;
    offset += 10; // Skip past the first few instructions
    
    // Add junk in the middle of the check function
    add_junk_code(polymorphic_code, &offset);
    
    // In a real polymorphic challenge, we would do more sophisticated 
    // modifications like instruction substitution, register reassignment,
    // control flow obfuscation, etc.
}

int main() {
    char input[100];
    unsigned char flag_copy[FLAG_LENGTH + 1];
    
    // Seed random number generator with current time
    srand(time(NULL));
    
    // Generate polymorphic code
    generate_polymorphic_code();
    
    // Make the polymorphic code executable
    void* executable_memory = mmap(NULL, POLY_CODE_SIZE, 
                                  PROT_READ | PROT_WRITE | PROT_EXEC,
                                  MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    if (executable_memory == MAP_FAILED) {
        perror("mmap failed");
        return 1;
    }
    
    // Copy our polymorphic code to executable memory
    memcpy(executable_memory, polymorphic_code, POLY_CODE_SIZE);
    
    // Get function pointers to our polymorphic functions
    DecryptFunc decrypt_func = (DecryptFunc)executable_memory;
    CheckFunc check_func = (CheckFunc)(executable_memory + 
                          get_func_size(decrypt_flag_template, check_flag_template));
    
    // Make a copy of the encrypted flag
    memcpy(flag_copy, encrypted_flag, FLAG_LENGTH);
    flag_copy[FLAG_LENGTH] = '\0';
    
    // Decrypt the flag using our polymorphic function
    decrypt_func(flag_copy, FLAG_LENGTH, key);
    
    // Prompt for password
    printf("Enter the password: ");
    fgets(input, sizeof(input), stdin);
    
    // Remove newline if present
    size_t input_len = strlen(input);
    if (input_len > 0 && input[input_len - 1] == '\n') {
        input[--input_len] = '\0';
    }
    
    // Check if password is correct
    if (check_func(input, input_len) && strcmp(input, (char*)flag_copy) == 0) {
        printf("Correct! The flag is: %s\n", flag_copy);
    } else {
        printf("Incorrect password.\n");
    }
    
    // Clean up
    munmap(executable_memory, POLY_CODE_SIZE);
    
    return 0;
} 